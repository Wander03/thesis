<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Thesis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="thesis_draft_files/libs/clipboard/clipboard.min.js"></script>
<script src="thesis_draft_files/libs/quarto-html/quarto.js"></script>
<script src="thesis_draft_files/libs/quarto-html/popper.min.js"></script>
<script src="thesis_draft_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="thesis_draft_files/libs/quarto-html/anchor.min.js"></script>
<link href="thesis_draft_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="thesis_draft_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="thesis_draft_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="thesis_draft_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="thesis_draft_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Thesis</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="abstract" class="level1">
<h1>Abstract</h1>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Since the early 1990s, frequent itemset mining (FIM) has been an important area of research in data mining. The work of Agrawal, Imieliński, and Swami <span class="citation" data-cites="agrawal_mining_1993">(<a href="#ref-agrawal_mining_1993" role="doc-biblioref">1993</a>)</span> introduced the Apriori algorithm, which established the foundation for identifying co-occurring items in transactional datasets. Shortly after, algorithms such as FP-growth’s FP-tree structure <span class="citation" data-cites="han_mining_2000">(<a href="#ref-han_mining_2000" role="doc-biblioref">Han, Pei, and Yin 2000</a>)</span> and Elcat’s vertical tid-list approach <span class="citation" data-cites="zaki_scalable_2000">(<a href="#ref-zaki_scalable_2000" role="doc-biblioref">Zaki 2000</a>)</span> significantly improved the performance and scalability of FIM techniques. These techniques have since been applied to a wide range of applications, including market basket analysis, web personalization <span class="citation" data-cites="mobasher_effective_2001">(<a href="#ref-mobasher_effective_2001" role="doc-biblioref">Mobasher et al. 2001</a>)</span>, and associative classification <span class="citation" data-cites="liu_integrating_1998">(<a href="#ref-liu_integrating_1998" role="doc-biblioref">Liu, Hsu, and Ma 1998</a>)</span>.</p>
<p>Although FIM has become more efficient, practical implementations remain confined to specialized software packages. The R programming environment offers itemset mining through <code>arules</code> <span class="citation" data-cites="hahsler_arules_2011">(<a href="#ref-hahsler_arules_2011" role="doc-biblioref">Hahsler et al. 2011</a>)</span>, while Python users rely on <code>mlxtend</code> <span class="citation" data-cites="raschka_mlxtend_2018">(<a href="#ref-raschka_mlxtend_2018" role="doc-biblioref">Raschka 2018</a>)</span> for similar functionality. However, these implementations share the same limitation: they operate as stand alone itemset mining applications rather than as integrated components in a modern data science workflow. The absence of native integration with frameworks like <code>tidymodels</code> <span class="citation" data-cites="kuhn_tidymodels_2020">(<a href="#ref-kuhn_tidymodels_2020" role="doc-biblioref">Kuhn and Wickham 2020</a>)</span> or <code>scikit-learn</code> <span class="citation" data-cites="buitinck_api_2013">(<a href="#ref-buitinck_api_2013" role="doc-biblioref">Buitinck et al. 2013</a>)</span> leaves a gap, forcing analysts to create their own custom solutions.</p>
<p>Another limitation lies in the interpretation of FIM results. Frequent itemsets are commonly treated as either final outputs, or inputs for generating association rules. However, research by Cheng et al. <span class="citation" data-cites="cheng_discriminative_2007">(<a href="#ref-cheng_discriminative_2007" role="doc-biblioref">2007</a>)</span> demonstrated that itemsets can also be used in classification tasks, meanwhile other studies have explored how itemsets can be used in clustering tasks <span class="citation" data-cites="mobasher_effective_2001 wickramaratna_predicting_2009">(<a href="#ref-mobasher_effective_2001" role="doc-biblioref">Mobasher et al. 2001</a>; <a href="#ref-wickramaratna_predicting_2009" role="doc-biblioref">Wickramaratna, Kubat, and Premaratne 2009</a>)</span>. Although these approaches lack a standardized method, the use of FIM in these methods indicates a potential for integration with clustering workflows.</p>
<p>This thesis seeks to address these limitations by introducing FIM to <code>tidyclust</code> <span class="citation" data-cites="hvitfeldt_tidyclust_2022">(<a href="#ref-hvitfeldt_tidyclust_2022" role="doc-biblioref">Hvitfeldt and Bodwin 2022</a>)</span>, a package designed for unsupervised learning algorithms within the <code>tidymodel</code> framework. By adapting the Apriori and Eclat algorithms to <code>tidyclust</code>, this work allows itemset mining to be used within unsupervised workflows. It also creates a standard methodology for predicting missing-items, and lays a foundation for future additions of mining and clustering techniques within <code>tidyclust</code>.</p>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<section id="frequent-itemset-mining-concepts-and-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="frequent-itemset-mining-concepts-and-algorithms">Frequent Itemset Mining: Concepts and Algorithms</h2>
<p>Frequent itemset mining (FIM) methods were developed to identify the elements of a transactional dataset that often occur together. The original use is in market basket research <span class="citation" data-cites="agrawal_mining_1993">(<a href="#ref-agrawal_mining_1993" role="doc-biblioref">Agrawal, Imieliński, and Swami 1993</a>)</span>, where FIM techniques help discover items commonly bought together. For example, a pattern could be that milk and eggs are frequently bought together in the same transaction. This type of information can be used by the shop owner to place these items apart from each other, causing customers to walk through more of the store. Although this task may appear simple, the number of itemsets rapidly grows in wider datasets, resulting in the development of more efficient algorithms. One such development is the principle that if an itemset is frequent, then so are all of its subsets; a property known as the Apriori principle or downward closure property. This principle significantly reduces the search space by systematically pruning candidate itemsets that do not meet a minimum support threshold. The two methods implemented in <code>tidyclust</code>, Apriori and Eclat, both operate on this principle.</p>
<section id="definitions" class="level3">
<h3 class="anchored" data-anchor-id="definitions">Definitions</h3>
<p>Some key terms used in frequent itemset mining have already been mentioned. In this section, we define and formalize these expressions.</p>
<p>Let <span class="math inline">\(I = \{i_1, i_2, \dots, i_m\}\)</span> be a set of items and <span class="math inline">\(D = \{t_1, t_2, \dots, t_n\}\)</span> a transactional dataset where each transaction <span class="math inline">\(t_j \subseteq I\)</span>. A non-empty subset <span class="math inline">\(X = \{i_1, i_2, ..., i_k\} \subseteq I\)</span> is an itemset, or k-itemset where <span class="math inline">\(k\)</span> is the number of items.</p>
<p>The support of an itemset <span class="math inline">\(X\)</span> is the proportion of transactions containing <span class="math inline">\(X\)</span>:</p>
<p><span class="math display">\[\text{support}(X) = \frac{|{t \in D \mid X ⊆ t}|}{|D|}\]</span></p>
<p>An itemset is considered frequent if its support is greater than or equal to a given minimum support threshold <span class="math inline">\(\sigma\)</span>, where <span class="math inline">\(0 \leq \sigma \leq 1\)</span>. The goal of FIM is to find the set of frequent itemsets corresponding to the users minimum support.</p>
</section>
<section id="the-apriori-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-apriori-algorithm">The Apriori Algorithm</h3>
<p>The apriori algorithm <span class="citation" data-cites="agrawal_mining_1993">(<a href="#ref-agrawal_mining_1993" role="doc-biblioref">Agrawal, Imieliński, and Swami 1993</a>)</span> implements a breadth-first search to identify frequent itemsets, leveraging the downward closure property. The method operates as follows:</p>
<ol type="1">
<li><p>Initialization (<span class="math inline">\(k = 1\)</span>): Scan the transactional dataset <span class="math inline">\(D\)</span> to compute the support of all 1-itemsets <span class="math inline">\(X\)</span>. Keep only those with support(<span class="math inline">\(X\)</span>) <span class="math inline">\(\geq \sigma\)</span>, forming the set of frequent 1-itemsets <span class="math inline">\(L_1\)</span>.</p></li>
<li><p>Candidate Generation (<span class="math inline">\(k &gt; 1\)</span>): Generate candidate k-itemsets <span class="math inline">\(C_k\)</span> by joining pairs of frequent (k - 1)-itemsets from <span class="math inline">\(L_{k-1}\)</span> that share the first <span class="math inline">\(k - 2\)</span> items:</p></li>
</ol>
<p><span class="math display">\[C_k = \{X \cup Y \mid X, Y \in L_{k - 1}, |X \cap Y| = k - 2\}\]</span></p>
<ol start="3" type="1">
<li><p>Pruning: Eliminate any candidate <span class="math inline">\(X \in C_k\)</span> where (k - 1)-subset of <span class="math inline">\(X\)</span> is not in <span class="math inline">\(L_{k - 1}\)</span> (downward closure property)</p></li>
<li><p>Support Counting: Scan the full dataset <span class="math inline">\(D\)</span> to compute the support(<span class="math inline">\(X\)</span>) for all <span class="math inline">\(X \in C_k\)</span>.</p></li>
<li><p>Iteration: Repeat steps 2-4 until no new frequent itemsets are found (<span class="math inline">\(L_k = \emptyset\)</span>).</p>
<p><span class="math inline">\(\bigcup_k L_k\)</span> is the set of frequent itemsets.</p></li>
</ol>
</section>
<section id="the-eclat-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-eclat-algorithm">The Eclat Algorithm</h3>
<p>The Equivalence Class Transformation (Eclat) algorithm <span class="citation" data-cites="zaki_scalable_2000">(<a href="#ref-zaki_scalable_2000" role="doc-biblioref">Zaki 2000</a>)</span> is an alternative to Apriori that uses a depth-first search strategy and vertical data representation. Instead of scanning the dataset repeatedly, Eclat represents transactions as tid-lists (transaction ID lists), which map each item or itemset to the IDs of transactions in which it appears. The method operates as follows:</p>
<ol type="1">
<li>Vertical Representation: Transform the transaction dataset <span class="math inline">\(D\)</span> into a vertical format, where each item <span class="math inline">\(x\)</span> maintains its tid-list:</li>
</ol>
<p><span class="math display">\[T(x) = {t \in D \mid x \in t}\]</span></p>
<p>Initialize the set of frequent 1-items:</p>
<p><span class="math display">\[L_1 = \{\{x\} \mid |T(x)| \geq \sigma \times |D|\}\]</span></p>
<ol start="2" type="1">
<li>Depth-First Search: For each frequent itemset <span class="math inline">\(X \in L_k\)</span>:</li>
</ol>
<ol type="a">
<li><p>Candidate Generation: Extend <span class="math inline">\(X\)</span> with items <span class="math inline">\(y &gt; max(X)\)</span> (lexicographic order) to form (k + 1)-itemset candidates <span class="math inline">\(X' = X \cup \{y\}\)</span>.</p></li>
<li><p>Tid-list Intersection: Compute the tid list of <span class="math inline">\(X’\)</span> with set intersection: <span class="math display">\[T(X’) = \bigcap_{x \in X’} T(x)\]</span></p></li>
<li><p>Support Verification: Keep <span class="math inline">\(X’\)</span> if: <span class="math display">\[\frac{|T(X’)|}{|D|} \geq \sigma\]</span> Add <span class="math inline">\(X’\)</span> to <span class="math inline">\(L_{k + 1}\)</span></p></li>
</ol>
<ol start="3" type="1">
<li>Termination: Repeat step 2 until no new frequent itemsets are found (<span class="math inline">\(L_k = \emptyset\)</span>).</li>
</ol>
</section>
</section>
<section id="tidyclust" class="level2">
<h2 class="anchored" data-anchor-id="tidyclust">tidyclust</h2>
<p>The <code>tidyclust</code> package <span class="citation" data-cites="hvitfeldt_tidyclust_2022">(<a href="#ref-hvitfeldt_tidyclust_2022" role="doc-biblioref">Hvitfeldt and Bodwin 2022</a>)</span> extends the <code>tidymodels</code> <span class="citation" data-cites="kuhn_tidymodels_2020">(<a href="#ref-kuhn_tidymodels_2020" role="doc-biblioref">Kuhn and Wickham 2020</a>)</span> framework to unsupervised tasks. These packages were built following the principles of the <code>tidyverse</code> <span class="citation" data-cites="wickham_welcome_2019">(<a href="#ref-wickham_welcome_2019" role="doc-biblioref">Wickham et al. 2019</a>)</span>, with the goal of establishing a consistent and reproducible workflow. Since the design of <code>tidyclust</code> is closely modeled off of <code>parsnip</code> <span class="citation" data-cites="kuhn_parsnip_2024">(<a href="#ref-kuhn_parsnip_2024" role="doc-biblioref">Kuhn and Vaughan 2024</a>)</span>, users are able to specify a clustering model, then fit and predict on the model using a standardized syntax.</p>
<section id="core-workflow" class="level3">
<h3 class="anchored" data-anchor-id="core-workflow">Core Workflow</h3>
<p>The <code>tidymodels</code> workflow, and therefore the <code>tidyclust</code> workflow, mirrors established practices in supervised modeling. The first step involves model specification and selection. For example, a K-means model with three clusters would be specified as:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>kmeans_spec <span class="ot">&lt;-</span> <span class="fu">k_means</span>(<span class="at">num_clusters =</span> <span class="dv">3</span>) <span class="sc">%&gt;%</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"stats"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>where the backend model is using the stats package.</p>
<p>The next step is data preparation, and is taken care of by <code>recipes</code> <span class="citation" data-cites="kuhn_recipes_2024">(<a href="#ref-kuhn_recipes_2024" role="doc-biblioref">Kuhn, Wickham, and Hvitfeldt 2024</a>)</span>. <code>recipes</code> support a range of data transformation, including normalization, standardization, and dummy variable creation as well as data cleaning steps such as missing value removal and imputation. The specification of a recipe follows a declarative syntax, improving both readability and reproducibility in the data cleaning and preparation process.</p>
<p>The final steps encompass model fitting and prediction. The fit() method accepts either raw data or a recipe object, and returns a <code>cluster_fit</code> object. This fitted object holds the trained model along with any metadata necessary for later operations. The predict() function takes the fitted object and new observations as inputs, outputting results in a standardized format. The functionality of predict() depends on the type of fitted model, for example the K-means model from before would predict which of the three clusters each new observation in the input data belongs to.</p>
<p>The remaining sections of this thesis will be dedicated to the examination of the design and implementation choices made while implementing FIM in <code>tidyclust.</code> Section 3 covers each step of the workflow detailed above, Section 4 addresses current limitations, and Section 5 concludes with proposed enhancements.</p>
</section>
</section>
</section>
<section id="methodology" class="level1">
<h1>Methodology</h1>
<section id="model-specification-and-itemset-based-clustering-framework" class="level2">
<h2 class="anchored" data-anchor-id="model-specification-and-itemset-based-clustering-framework">Model Specification and Itemset-Based Clustering Framework</h2>
</section>
<section id="prediction-methods-for-frequent-itemset-models" class="level2">
<h2 class="anchored" data-anchor-id="prediction-methods-for-frequent-itemset-models">Prediction Methods for Frequent Itemset Models</h2>
</section>
<section id="hyperparameter-tuning-and-performance-metrics" class="level2">
<h2 class="anchored" data-anchor-id="hyperparameter-tuning-and-performance-metrics">Hyperparameter Tuning and Performance Metrics</h2>
</section>
</section>
<section id="limitations" class="level1">
<h1>Limitations</h1>
<section id="analysis-of-implementation-limitations" class="level2">
<h2 class="anchored" data-anchor-id="analysis-of-implementation-limitations">Analysis of Implementation Limitations</h2>
</section>
<section id="future-directions" class="level2">
<h2 class="anchored" data-anchor-id="future-directions">Future Directions</h2>
</section>
</section>
<section id="references" class="level1">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-agrawal_mining_1993" class="csl-entry" role="listitem">
Agrawal, Rakesh, Tomasz Imieliński, and Arun Swami. 1993. <span>“Mining Association Rules Between Sets of Items in Large Databases.”</span> <em>SIGMOD Rec.</em> 22 (2): 207–16. <a href="https://doi.org/10.1145/170036.170072">https://doi.org/10.1145/170036.170072</a>.
</div>
<div id="ref-buitinck_api_2013" class="csl-entry" role="listitem">
Buitinck, Lars, Gilles Louppe, Mathieu Blondel, Fabian Pedregosa, Andreas Mueller, Olivier Grisel, Vlad Niculae, et al. 2013. <span>“<span>API</span> Design for Machine Learning Software: Experiences from the Scikit-Learn Project.”</span> In <em><span>ECML</span> <span>PKDD</span> <span>Workshop</span>: <span>Languages</span> for <span>Data</span> <span>Mining</span> and <span>Machine</span> <span>Learning</span></em>, 108–22.
</div>
<div id="ref-cheng_discriminative_2007" class="csl-entry" role="listitem">
Cheng, Hong, Xifeng Yan, Jiawei Han, and Chih-Wei Hsu. 2007. <span>“Discriminative <span>Frequent</span> <span>Pattern</span> <span>Analysis</span> for <span>Effective</span> <span>Classification</span>.”</span> In <em>2007 <span>IEEE</span> 23rd <span>International</span> <span>Conference</span> on <span>Data</span> <span>Engineering</span></em>, 716–25. <a href="https://doi.org/10.1109/ICDE.2007.367917">https://doi.org/10.1109/ICDE.2007.367917</a>.
</div>
<div id="ref-hahsler_arules_2011" class="csl-entry" role="listitem">
Hahsler, Michael, Sudheer Chelluboina, Kurt Hornik, and Christian Buchta. 2011. <span>“The Arules <span>R</span>-<span>Package</span> <span>Ecosystem</span>: <span>Analyzing</span> <span>Interesting</span> <span>Patterns</span> from <span>Large</span> <span>Transaction</span> <span>Datasets</span>.”</span> <em>Journal of Machine Learning Research</em> 12: 1977–81. <a href="https://jmlr.csail.mit.edu/papers/v12/hahsler11a.html">https://jmlr.csail.mit.edu/papers/v12/hahsler11a.html</a>.
</div>
<div id="ref-han_mining_2000" class="csl-entry" role="listitem">
Han, Jiawei, Jian Pei, and Yiwen Yin. 2000. <span>“Mining Frequent Patterns Without Candidate Generation.”</span> <em>SIGMOD Rec.</em> 29 (2): 1–12. <a href="https://doi.org/10.1145/335191.335372">https://doi.org/10.1145/335191.335372</a>.
</div>
<div id="ref-hvitfeldt_tidyclust_2022" class="csl-entry" role="listitem">
Hvitfeldt, Emil, and Kelly Bodwin. 2022. <span>“Tidyclust: <span>A</span> <span>Common</span> <span>API</span> to <span>Clustering</span>.”</span> <a href="https://doi.org/10.32614/CRAN.package.tidyclust">https://doi.org/10.32614/CRAN.package.tidyclust</a>.
</div>
<div id="ref-kuhn_parsnip_2024" class="csl-entry" role="listitem">
Kuhn, Max, and Davis Vaughan. 2024. <em>Parsnip: <span>A</span> <span>Common</span> <span>API</span> to <span>Modeling</span> and <span>Analysis</span> <span>Functions</span></em>. <a href="https://CRAN.R-project.org/package=parsnip">https://CRAN.R-project.org/package=parsnip</a>.
</div>
<div id="ref-kuhn_tidymodels_2020" class="csl-entry" role="listitem">
Kuhn, Max, and Hadley Wickham. 2020. <em>Tidymodels: A Collection of Packages for Modeling and Machine Learning Using Tidyverse Principles.</em> <a href="https://www.tidymodels.org">https://www.tidymodels.org</a>.
</div>
<div id="ref-kuhn_recipes_2024" class="csl-entry" role="listitem">
Kuhn, Max, Hadley Wickham, and Emil Hvitfeldt. 2024. <em>Recipes: <span>Preprocessing</span> and <span>Feature</span> <span>Engineering</span> <span>Steps</span> for <span>Modeling</span></em>. <a href="https://CRAN.R-project.org/package=recipes">https://CRAN.R-project.org/package=recipes</a>.
</div>
<div id="ref-liu_integrating_1998" class="csl-entry" role="listitem">
Liu, Bing, Wynne Hsu, and Yiming Ma. 1998. <span>“Integrating Classification and Association Rule Mining.”</span> In <em>Proceedings of the <span>Fourth</span> <span>International</span> <span>Conference</span> on <span>Knowledge</span> <span>Discovery</span> and <span>Data</span> <span>Mining</span></em>, 80–86. <span>KDD</span>’98. New York, NY: AAAI Press.
</div>
<div id="ref-mobasher_effective_2001" class="csl-entry" role="listitem">
Mobasher, Bamshad, Honghua Dai, Tao Luo, and Miki Nakagawa. 2001. <span>“Effective Personalization Based on Association Rule Discovery from Web Usage Data.”</span> In <em>Proceedings of the 3rd <span>International</span> <span>Workshop</span> on <span>Web</span> <span>Information</span> and <span>Data</span> <span>Management</span></em>, 9–15. <span>WIDM</span> ’01. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/502932.502935">https://doi.org/10.1145/502932.502935</a>.
</div>
<div id="ref-raschka_mlxtend_2018" class="csl-entry" role="listitem">
Raschka, Sebastian. 2018. <span>“<span>MLxtend</span>: <span>Providing</span> Machine Learning and Data Science Utilities and Extensions to <span>Python</span>’s Scientific Computing Stack.”</span> <em>The Journal of Open Source Software</em> 3 (24). <a href="https://doi.org/10.21105/joss.00638">https://doi.org/10.21105/joss.00638</a>.
</div>
<div id="ref-wickham_welcome_2019" class="csl-entry" role="listitem">
Wickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. <span>“Welcome to the Tidyverse.”</span> <em>Journal of Open Source Software</em> 4 (43): 1686. <a href="https://doi.org/10.21105/joss.01686">https://doi.org/10.21105/joss.01686</a>.
</div>
<div id="ref-wickramaratna_predicting_2009" class="csl-entry" role="listitem">
Wickramaratna, Kasun, Miroslav Kubat, and Kamal Premaratne. 2009. <span>“Predicting <span>Missing</span> <span>Items</span> in <span>Shopping</span> <span>Carts</span>.”</span> <em>IEEE Transactions on Knowledge and Data Engineering</em> 21 (7): 985–98. <a href="https://doi.org/10.1109/TKDE.2008.229">https://doi.org/10.1109/TKDE.2008.229</a>.
</div>
<div id="ref-zaki_scalable_2000" class="csl-entry" role="listitem">
Zaki, M. J. 2000. <span>“Scalable Algorithms for Association Mining.”</span> <em>IEEE Transactions on Knowledge and Data Engineering</em> 12 (3): 372–90. <a href="https://doi.org/10.1109/69.846291">https://doi.org/10.1109/69.846291</a>.
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>